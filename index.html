<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사라지는 텍스트 훈련</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 5px; transition: opacity 0.3s, background-color 0.3s; background-color: #f5f5f5; overscroll-behavior: none; position: relative; touch-action: pan-y; overflow-x: hidden; }
        #textContent { font-size: 18px; line-height: 1.6; white-space: pre-wrap; position: relative; overflow-y: hidden; overflow-x: hidden; width: 100%; height: calc(70vh - 80px); margin: 0 auto; padding: 10px; box-sizing: border-box; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); z-index: 1; transition: transform 0.3s ease, background-color 0.3s, color 0.3s; color: #333; user-select: none; }
        .fullscreen #textContent { width: 100vw; height: 100vh; margin: 0; padding: 20px; }
        /* 기존 스타일 유지, 생략 */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nosleep.js@1.1.0/dist/NoSleep.min.js"></script>
</head>
<body>
    <input type="file" id="fileUpload" accept=".txt,.epub" aria-label="파일 업로드" multiple>
    <div id="controls" role="toolbar">
        <button id="toggleButton" aria-label="훈련 시작/중지">시작</button>
        <button id="prevPage" aria-label="이전 페이지"><span class="icon">◀</span> 이전</button>
        <button id="nextPage" aria-label="다음 페이지"><span class="icon">▶</span> 다음</button>
        <button id="tocButton" aria-label="목차">목차</button>
        <button id="libraryButton" aria-label="라이브러리">라이브러리</button>
        <input type="number" id="jumpToPage" min="1" placeholder="페이지로 이동" style="width: 100px; padding: 5px;">
    </div>
    <details>
        <summary>고급 설정</summary>
        <div id="advancedControls">
            <label for="speedControl">속도 (빠름: 50ms ~ 느림: 2000ms):</label>
            <input type="range" id="speedControl" min="50" max="2000" step="1" value="100">
            <label for="fontSizeRange">글꼴 크기:</label>
            <input type="range" id="fontSizeRange" min="12" max="36" value="18">
            <input type="number" id="fontSize" min="12" max="36" value="18">px
            <label for="textMaxWidth">최대 너비 (%):</label>
            <input type="number" id="textMaxWidth" min="50" max="100" value="100" step="1">
            <label for="textMaxHeight">최대 높이 (%):</label>
            <input type="number" id="textMaxHeight" min="50" max="100" value="100" step="1">
            <label for="touchSensitivity">터치 민감도 (px):</label>
            <input type="number" id="touchSensitivity" min="10" max="100" value="50" step="10">
            <label for="effectDelay">효과 재시작 지연 (ms):</label>
            <input type="number" id="effectDelay" min="0" max="2000" value="400" step="100">
            <label for="applyEffectDelay">효과 지연 적용:</label>
            <input type="checkbox" id="applyEffectDelay" checked>
            <label for="doubleTapDelay">더블탭 지연 (ms):</label>
            <input type="number" id="doubleTapDelay" min="200" max="1000" value="300" step="50">
            <!-- 기존 설정 항목 유지, 생략 -->
        </div>
    </details>
    <div id="textContent" role="region" aria-label="텍스트 표시 영역">
        <div id="pageInfo" aria-live="polite"></div>
    </div>
    <!-- 기존 HTML 구조 유지, 생략 -->

    <script>
        const textContent = document.getElementById('textContent');
        const toggleButton = document.getElementById('toggleButton');
        const fontSize = document.getElementById('fontSize');
        const fontSizeRange = document.getElementById('fontSizeRange');
        const textMaxWidth = document.getElementById('textMaxWidth');
        const textMaxHeight = document.getElementById('textMaxHeight');
        const touchSensitivity = document.getElementById('touchSensitivity');
        const effectDelay = document.getElementById('effectDelay');
        const applyEffectDelay = document.getElementById('applyEffectDelay');
        const doubleTapDelay = document.getElementById('doubleTapDelay');
        let interval, pages = [], currentPage = 0, isFullscreen = false;

        fontSizeRange.oninput = fontSize.oninput = () => {
            fontSize.value = fontSizeRange.value;
            textContent.style.fontSize = `${fontSize.value}px`;
            localStorage.setItem('fontSize', fontSize.value);
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
        };

        textMaxWidth.addEventListener('input', updateTextContentStyles);
        textMaxHeight.addEventListener('input', updateTextContentStyles);
        function updateTextContentStyles() {
            textContent.style.width = `calc(${textMaxWidth.value}vw - ${marginLeft.value}vw - ${marginRight.value}vw)`;
            textContent.style.height = `calc(${textMaxHeight.value}vh - ${marginTop.value}vh - ${marginBottom.value}vh - 80px)`;
            textContent.style.maxWidth = `${textMaxWidth.value}vw`;
            textContent.style.maxHeight = `${textMaxHeight.value}vh`;
            textContent.style.fontSize = `${fontSize.value}px`;
            pages = splitTextToFit(pages.join('\n\n'), textContent.getBoundingClientRect().height);
            preloadPages();
            displayPage();
        }

        let touchStartX = 0, touchTimeout;
        textContent.addEventListener('touchstart', (e) => { touchStartX = e.touches[0].clientX; });
        textContent.addEventListener('touchend', (e) => {
            clearTimeout(touchTimeout);
            touchTimeout = setTimeout(() => {
                const deltaX = e.changedTouches[0].clientX - touchStartX;
                const sensitivity = parseInt(touchSensitivity.value);
                if (deltaX > sensitivity && currentPage > 0) {
                    currentPage--;
                    stopEffect();
                    displayPage(-1);
                } else if (deltaX < -sensitivity && currentPage < pages.length - 1) {
                    currentPage++;
                    stopEffect();
                    displayPage(1);
                }
            }, 50);
        });

        effectDelay.value = localStorage.getItem('effectDelay') || 400;
        effectDelay.addEventListener('change', () => {
            let value = Math.min(2000, Math.max(0, parseInt(effectDelay.value) || 0));
            effectDelay.value = value;
            localStorage.setItem('effectDelay', value);
        });

        function displayPage(direction = 0) {
            textContent.innerHTML = renderedPages[currentPage] || '';
            updateTextContentStyles();
            if (pageAnimation.checked && applyEffectDelay.checked) {
                textContent.style.transform = 'translateX(0)';
                textContent.style.opacity = 1;
                setTimeout(() => { if (autoRestart.checked && interval) startEffect(); }, parseInt(effectDelay.value));
            } else if (autoRestart.checked && interval && applyEffectDelay.checked) {
                setTimeout(() => startEffect(), parseInt(effectDelay.value));
            }
        }

        const hammer = new Hammer(textContent);
        hammer.get('doubletap').set({ interval: parseInt(doubleTapDelay.value) });
        hammer.on('doubletap', () => {
            if (isFullscreen) {
                stopEffect();
                exitFullscreen();
            }
        });
        doubleTapDelay.addEventListener('change', () => {
            hammer.get('doubletap').set({ interval: parseInt(doubleTapDelay.value) });
            localStorage.setItem('doubleTapDelay', doubleTapDelay.value);
        });

        function startEffect() {
            stopEffect();
            const effect = effectSelect.value;
            const intervalTime = parseInt(speedControl.value);
            if (effect === 'fade') {
                let opacity = 1;
                interval = setInterval(() => {
                    if (opacity > 0) {
                        opacity -= 0.05;
                        textContent.style.opacity = opacity;
                    } else {
                        clearInterval(interval);
                        if (currentPage < pages.length - 1) nextPage.click();
                    }
                }, intervalTime);
            } else {
                let frameId;
                const spans = textContent.querySelectorAll('.char-span:not(.char-space)');
                let charIndex = 0;
                function step() {
                    if (charIndex < spans.length) {
                        spans[charIndex].style.opacity = 0;
                        charIndex++;
                    } else {
                        cancelAnimationFrame(frameId);
                        if (currentPage < pages.length - 1) nextPage.click();
                    }
                    frameId = requestAnimationFrame(step);
                }
                frameId = requestAnimationFrame(step);
                interval = { cancel: () => cancelAnimationFrame(frameId) };
            }
        }

        function stopEffect() {
            if (interval) {
                if (interval.cancel) interval.cancel();
                else clearInterval(interval);
            }
            interval = null;
        }

        function exitFullscreen() {
            if (document.fullscreenElement) document.exitFullscreen();
            document.body.classList.remove('fullscreen');
            isFullscreen = false;
        }

        toggleButton.addEventListener('click', () => {
            if (!isTrainingActive) {
                if (fullscreenMode.checked) document.documentElement.requestFullscreen();
                startEffect();
                toggleButton.innerText = '정지';
                isTrainingActive = true;
            } else {
                stopEffect();
                exitFullscreen();
                toggleButton.innerText = '시작';
                isTrainingActive = false;
            }
        });

        // 기존 JavaScript 함수들 (splitTextToFit, preloadPages 등) 유지, 생략
    </script>
</body>
</html>